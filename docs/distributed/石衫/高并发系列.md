
# MQ
## 优点：
- 解耦：
发布订阅模式 -> BCD系统去 pull or push
- 异步: 写库操作。mq消费写库，直接返回客户端
- 削峰：每个时间点 -> 大量的消息 -> mysql 的写 2000QPS, 每秒请求 5000，可以将 请求封装 -> mq -> 慢慢的消费

## 缺点

1. 系统复杂度升高 -> 增加了复杂度
2. 系统可用性降低 -> mq挂了
## 问题
1. 重复消费的问题 幂等性
2. 消息堆积的问题
3. 消息顺序问题
4. 高可用问题
5. 消息丢失问题

# redis缓存
## 优点
- 高性能
对于复杂的查询操作 -> 缓存
- 高并发
mysql 这种数据 涉及 IO 操作 -> 不能支持高并发的查询，可以支持 几万 的 QPS
## 问题
1. 缓存一致性的问题
2. 高可用的问题
3. 缓存穿透的问题 缓存雪崩 缓存并发竞争 

## 对比 memcached
1. string 2. 集群 

## 线程模型
`file event handler` 文件事件处理器，单线程，IO多路复用机制监听多个 socket 将产生事件的socket压入队列，事件分派器根据事件类型选择相应的处理器进行处理。
- 多个socket
- IO 多路复用
- 事件处理器

redis与客户端进行一次通信的过程

![redis-single-thread-model](./images/redis-single-thread-model.png)

客户端 socket01 向 redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 `AE_READABLE` 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给**连接应答处理器**。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 `AE_READABLE` 事件与命令请求处理器关联。

假设此时客户端发送了一个 `set key value` 请求，此时 redis 中的 socket01 会产生 `AE_READABLE` 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 `AE_READABLE` 事件，由于前面 socket01 的 `AE_READABLE` 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 `key value` 并在自己内存中完成 `key value` 的设置。操作完成后，它会将 socket01 的 `AE_WRITABLE` 事件与命令回复处理器关联。

如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 `AE_WRITABLE` 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 `ok`，之后解除 socket01 的 `AE_WRITABLE` 事件与命令回复处理器的关联。

## 为啥 redis 单线程模型也能效率这么高

- 纯内存操作。
- 核心是基于非阻塞的 IO 多路复用机制。
- C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。
- 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。
## 哨兵机制

哨兵机制实现了 redis 集群的高可用性。
- 集群监控： 监控redis 节点是否正常工作
- 消息通知： redis 节点挂了，通知管理员
- 选举新的master
- master挂了，通知client

判断一个 master node 挂了，是需要大多数的哨兵同意，涉及选举的问题。哨兵是集群的，至少 3个实例。
`哨兵` +`redis主从集群`只能保证集群的高可用，并不能保证数据不丢失。

## 数据情况丢失的问题

1. redis 是异步复制，master -> slave ，master挂了，丢失数据
2. `脑裂` 某个 master 网络不好，导致 哨兵以为它 挂了，重新进行选举 -> client 没来得及切换数据 -> `继续向旧的master写数据` -> 旧的master 数据被清空 -> 挂到新的 master上作为 slave,后来client写的数据就丢失了

## 数据丢失问题的解决方案

1. 至少一个 slave,数据复制 不超过 10秒，如果都超过10秒，master就不接受任何请求了
2. 减少数据同步的复制
3. 脑裂情况下还是会丢失数据，只不过丢失的是10秒的

## slave -> master 选举算法（待看）

## 生产环境
1. 集群的搭建由 运维部门基础架构部门负责（这个自己搭建的概率比较低）
2. 每个节点 5万 QPS
3. 10G 分给 redis
4. 32G+8CPU+300G

## 持久化

- RDB: 周期性持久化，冷备份，完成的文件上传云，恢复更快，fork子进程，进行 RDB持久化。
- AOF： `append-only`,数据损失小，在redis.conf中有相关的配置。append 数据文件大，支持压缩。具体参考 redis 持久化文章



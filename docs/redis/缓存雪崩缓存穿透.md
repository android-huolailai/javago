# 缓存雪崩缓存穿透

## 缓存雪崩

缓存雪崩是因为 采用了相同的过期时间，导致缓存在某一个时刻同时失效，所有的查询全部落在了数据库上面，造成了缓存雪崩。

解决方案：

- 不同的key设置不同的过期时间（随机因子）设置提前过期的标志位，提前采用线程进行更新。（我比较喜欢这个）
- 二级缓存 ，建立备份缓存，A,B。A读不到，去B读取。
- 加锁排队。永不失效。

## 缓存穿透：

正常情况下，查询的数据都存在，如果请求一个不存在的数据，也就是缓存和数据库都查不到这个数据，每次都会去数据库查询，这种查询不存在数据的现象我们称为缓存穿透.

## 缓存穿透带来的问题：

每次都是拿一个不存在的id去查询数据库，可能造成数据库的压力增大。

## 缓存穿透的解决办法

- 缓存空值。 之所以发生缓存穿透。
- BloomFilter [BloomFilter](../datastructure/other/BloomFilter.md)
类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中
我们把有数据的key都放到BloomFilter中，每次查询的时候都先去BloomFilter判断，如果没有就直接返回null
注意BloomFilter没有删除操作，对于删除的key，查询就会经过BloomFilter然后查询缓存再查询数据库，所以BloomFilter可以结合缓存空值用，对于删除的key，可以在缓存中缓存null。

## 缓存击穿

在高并发的情况下，大量的请求同时查询同一个key时，此时这个key正好失效了，就会导致同一时间，这些请求都会去查询数据库，这样的现象我们称为缓存击穿

解决办法
采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有

[参考文章链接](https://juejin.im/post/5ca8905ef265da30ba5b18bc)


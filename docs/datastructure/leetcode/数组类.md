1. 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

```java
    // 查找到任意一个数组中重复的数字 数字范围 0-n-1
    public void findRepeatedNum() {
        int [] nums = {2, 3, 1, 0, 2, 5, 3};
        int repeatNum = -1;
        for (int i=0; i<nums.length;i++) {
            int currNum = nums[i];
            int otherNum = nums[currNum];
            if(currNum == otherNum) {
                repeatNum = currNum;
                break;
            }
            swap(nums, i, currNum);
        }
        System.out.println("repeated" + repeatNum); // 2
    }
    public  void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```
2. 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
思路： <font color='red'>冒泡排序</font>
```java
    // 奇数位于数组的前半部分，所有的偶数位于数组的后半部分，
    // 并保证奇数和奇数，偶数和偶数之间的相对位置不变
    public static void sortOddEvenNum(int[] array) {
        // 思路：两个指针，一个负责奇数 一个负责偶数
        // 如何保证相对的顺序？难道统计一下奇数 偶数的个数？
        // 先尝试统计一下吧(如果建立新的数组就非常容易解决了，但是不想用这种办法)

        // 使用冒泡排序的思想?(重点)
        for (int i = array.length -1; i>0;i--) {
            for (int j = 0;j <i;j++) { // 外层循环倒着只是控制尾值的
                if (array[j] %2 ==0 && array[j+1] %2 != 0) {
                    swap(array, j, j+1);
                }
            }
        }
    }
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```



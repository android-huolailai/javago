本文所有的内容都是在工作之余整理。主要是自己知识区的盲点。为了来年做好准备。

# Java

1. 快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？
    fail-fast :ConcurrentModificationException -> foreach remove-> 先记录一下，每次迭代判断 -> HashMap
    单线程的迭代删除，多线程的修改
    fail-safe: 对集合的修改是在copy的基础上。CopyOnWirteArrayList, ConcurrentHashMap
    fail-fast: 迭代删除 ， java8 removeIf map.keySet().removeIf();

2. HashMap
    getNode first判断 -> hash,key,value校验 -> is TreeNode ? TreeSearch : Next do while
    Node[] ; hash &(length-1) ; put new Node change val
    红黑树 logN 
    对于put操作，如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。如果Key对应的数组元素（链表表头或树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率

    将链表转换成红黑树前判断，如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树
    hashmap转红黑树的两个条件:一个是链表长度到8,一个是数组长度到64.

3. HashSet 和 TreeSet 有什么区别
   hashSet :无序
   treeSet：有序 Compartor
   LinkedHashSet是一种有序的Set集合，即其元素的存入和输出的顺序是相同的
4. Iterator 和 ListIterator 的区别是什么？
5. 序列化 与反序列化的大坑，参考我的 core/序列化与反序列化.md
6. TreeSet 底层也是 TreeMap. 通过equals去重。 HashSet 底层是 HashMap
7. 下面这条语句一共创建了多少个对象：String s="a"+"b"+"c"+"d";
```
        对于如下代码：
        String s1 = "a";
        String s2 = s1 + "b";
        String s3 = "a" + "b";
        System.out.println(s2 == "ab");
        System.out.println(s3 == "ab");
        第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期再去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。
        题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码，
                String s ="a" + "b" +"c" + "d";
                System.out.println(s== "abcd");
        最终打印的结果应该为true。
```
8. 当try和finally里都有return时，会忽略try的return，而使用finally的return。finally没有return时候，将 try return的存储起来，然后最后return回去。
9. jvm 在编译时期将 boolean 类型的数据转换为int ，boolean 使用 byte数组实现的。

为什么不用byte或short，这样不是更节省内存空间吗。经过查阅资料发现，使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），32 位 CPU 使用 4 个字节是最为节省的，哪怕你是 1 个 bit 他也是占用 4 个字节。因为 CPU 寻址系统只能 32 位 32 位地寻址，具有高效存取的特点。

10. since9 string 底层使用 byte[] 而不再是 char[], byte 1个字节，char 两个字节。

11. string final 好处？ 1. 可以使用 string pool, 2. 缓存hash值 3. 传输安全 线程安全
12. 1.1字面量为 double 类型，所以不能 直接 float a = 1.1 ，因为向下转型，会丢失精度，所以要在后面加f
13. short s1= 1;s1 =s1+1; 不行。-> s1+=1;可以，因为做了隐式的转换。
14.   a-b< 0 b>a a -b 存在溢出

15. 编译不通过 类型擦除 泛型遇上重载
```java
    public static void method(List<String> list) {  
        System.out.println("invoke method(List<String> list)");  
    }  

    public static void method(List<Integer> list) {  
        System.out.println("invoke method(List<Integer> list)");  
    }  
}  
```
16. 数据溢出的问题
17. int的自动装箱都是通过Integer.valueOf()方法来实现的，Integer的自动拆箱都是通过integer.intValue来实现的。
18. String s = "a" + "b"，编译器会进行常量折叠(因为两个都是编译期常量，编译期可知)，即变成 String s = "ab"
对于能够进行优化的(String s = "a" + 变量 等)用 StringBuilder 的 append() 方法替代，最后调用 toString() 方法 (底层就是一个 new String())
19. for 循环使用 sb,其他时候使用 + 没问题，因为底层使用 的是 StringBuilder 但是for中每次都是 StringBuilder
20. 静态代理的用途 控制真实对象的访问权限 通过代理对象控制对真实对象的使用权限。
21. 因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理
22. interrupt() 与 interrupted()方法，以及 sleep
23. shutdown -> no new task 之前提交的执行完成
    shutdownnow -> interrupt方法 ->设置所有的为interrupt -> remove 队列中的 -> return -> 不保证interrupt生效
24. 通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛
    出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。 
25. 如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future<?> 对
    象，通过调用该对象的 cancel(true) 方法就可以中断线程 

26. blockQueue.put 阻塞， add -> throws ex offer-> return false;







# SQL
```sql
delete p1 from Person p1, Person p2 where p1.Email = p2.Email and p1.Id > p2.Id; --删除 重复邮件

select e1.Name from Employee e1 inner join Employee e2 on e1.Salary > e2.Salary and e1.ManagerId = e2.Id; -- 查询工资大于其经理工资的员工

# 查找每个部门薪资最高的人
select D.Name as Department,E.Name as Employee,M.Salary as Salary from 
    Department as D,
    Employee   as E,
    (select max(Salary) as Salary,DepartmentId from Employee group by DepartmentId) as M
    where E.DepartmentId = D.Id and E.Salary = M.Salary and E.DepartmentId = M.DepartmentId;

select (select DISTINCT Salary from Employee order by Salary desc limit 1,1) SecondHighestSalary; -- 查询第 二高的人，没有返回null (注意去重)

-- 做到 178 178. Rank Scores
```

